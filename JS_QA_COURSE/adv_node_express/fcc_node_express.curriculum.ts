/* 
'pug@~3.0.0' has already been installed, and is listed as a dependency in your 'package.json' file.
Express needs to know which template engine you are using. Use the 'set' method to assign 'pug' as the 'view engine' property's value.
	
	app.set('view engine', 'pug');

After that, add another 'set' method that sets the 'views' property of your 'app' to point to the './views/pug' directory. This tells Express to render all views relative to that directory.
Finally, use 'res.render()' in the route for your home page, passing 'index' as the first argument. This will render the 'pug' template.
*/

// -----------------------------------------------------------------------------

/*
One of the greatest features of using a template engine is being able to pass variables from the server to the template file before rendering it to HTML.
In your Pug file, you're able to use a variable by referencing the variable name as '#{variable_name}' inline with other text on an element or by using an equal sign on the element without a space such as 'p=variable_name' which assigns the variable's value to the p element's text.
Pug is all about using whitespace and tabs to show nested elements and cutting down on the amount of code needed to make a beautiful site. EXMPL:

	head
		script(type='text/javascript').
			if (foo) bar(1+5);
	body
		if youAreUsingPug
			p You are amazing
		else 
			p Get on it!

The above yields as the HTML - it's easy.
- Your 'index.pug' file included in your project, uses the variables 'title' and 'message'.
Pass those from your server to the Pug file by adding an object as a second argument to your 'res.render' call with the variables and their values. Give the 'title' a value of 'Hello' and 'message' a value of 'Please log in'.
- It should look like:
	
	res.render('index', { title: 'Hello', message: 'Please log in' });

Now refresh page, and it should display those values rendered in your view in the correct spot as laid out in your 'index.pug' file.

// -----------------------------------------------------------------------------

/* 
It's time to set up Passprt so you can finally stary allowing a user to register or log in to an account. In addition to Passport, you will use Express-session to handle sessions. Express-session has a ton of advanced features you can use, but for now you are just going to use the basics. Using this middleware saves the session id as a cookie in the client, and allows us to access the session data using that id on the server. This way, you keep personal account information out of the cookie used by the client to tell to your server clients are authenticated and keep the key to access the data stored on the server.
'passport@~0.4.1' and 'express-session@~1.7.1' are already installed, and are both listed as dependencies in your 'package.json' file.
- You will need to set up the session settings and initialize Passport. First, create the variables 'session' and 'passport' to require 'express-session' and 'passport' respectively.
- Then, set up your Express app to use the session by defining the following options:

	app.use(session({
		secret: process.env.SESSION_SECRET,
		resave: true,
		saveUninitialized: true,
		cookie: { secure: false }
	}));
	
-Be sure to add 'SESSION_SECRET' to your '.env' file, and give it a random value. This is used to compute the hash used to encrypt your cookie!
After you do all that, tell your express app to use 'passport.initialize()' and 'passport.session()' .
*/

// -----------------------------------------------------------------------------

/*
Serialization and deserialization are important concepts in regard to authentication. To serialize an object means to convert its contents into a small key that can then be deserialized into the original object. This is what allows us to knwo who has communicated with the server without having to send the authentication data, like the username and passwords, at each request for a new page.
To set this up properly, you need to have a serialize function and a deserialize function. In Passport, these can be created with:
	
	passport.serializeUser(cb);
	passport.deserializeUser(cb);

The callback funcrtion passed to 'serializeUser' is called with two arguments: the full user object, and a callback used by passport.
- The callback expects two arguments: An error, if any, and a unique key to identify the user that should be returned in the callback. You will use the user's '_id' in the object. This is guaranteed to be unique, as it is generated by MongoDB.
Similarly, 'deserializeUser' is called with two arguments: the unique key, and a callback function.
This callback expects 2 arguments: An erorr, if any, and the full user object. To get the full user object, make a query search for a Mongo '_id', as shown below:

	passport.serializeUser((user, done) => {
		done(null, user._id);
	});
	
	passport.deserializeUser((id, done) => {
		myDataBase.findOne({ _id: new ObjectID(id) }, (err, doc) => {
			done(null, null);
		});
	});

-Add the two functions above to your server. The 'ObjectID' class comes from the 'mongodb' package. 'mongodb@~3.6.0' has already been added as a dependency. Declare this class with:

	const { ObjectID } = require('mongodb');
	
The 'deserializeUser' will throw an error until you set up the database connection. So, for now, comment out the 'myDatabase.findOne' call, and just call 'done(null, null)' in the 'deserializeUser' callback function.
*/

// -----------------------------------------------------------------------------

/*
You are not loading an actual user object since the database is not set up. Connect to the database once, when you start the server, and keep a persistent connection for the full life-cycle of the app. To do this, add your database's connection string (for example: 'mongodb+srv://<username>:<password>@cluster0-jvwxi.mongodb.net/?retryWrites=true&w=majority)' to the environment variable 'MONGO_URI'. This is used in the 'connection.js' file.
- Now you want to connect to your database, then start listening for requests. The purpose of this is not allow requests before your database is connected or if there is a database error. To accomplish this, encompass your serialization and app routes in the following code:

	myDB(async client => {
		const myDataBase = await client.db('database').collection('users');
		
		// Be sure to change the title
		app.route('/').get((req, res) => {
			// Change the response to render the Pug template
			res.render('idnex', {
				title: 'Connected to Database',
				message: 'Please login'
			});
		});
		// Serialization and deserialzation here ...
		
		// Be sure to add this..
	}).catch(e => {
		app.route('/').get((req, res) => {
			res.render('index', { title: e, message: 'Unable to connect to database' });
		});
	});
	// app.listen out here...
	
...
*/

// -----------------------------------------------------------------------------